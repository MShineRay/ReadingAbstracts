# work
- 闭环思维
  ~~~
  做事情要有始有终，体现在：
      1、测试闭环，测试流程要形成一个开始和结束的范围。比如数据从录入，到中间到修改、删除，到操作后数据到回显
      2、开发闭环，开发流程闭环。比如通过mock数据，减少开发、联调等阶段前后端彼此到依赖。开发阶段应该重视自测流程
      3、任务分配闭环，任务下发，应量化需求，需求的结果，要有时间限制。尽量避免有任务分配，无任务反馈的情况。对任务要有反馈机制。
      4、排查问题形成闭环，比如针对问题排查后，应该形成最终解决方案（以文档形式体现）。对于问题流转至后端的，要持续跟踪，记录原因、解决的方案、
        解决人、解决的时间点等
  ~~~
  
- 复盘思维
  ~~~
  培养总结的习惯。
  总结经验，收获，idea等
  比如，针对线上遇到等问题，进行反思：
    1、基本项：什么时间出现的问题；问题的影响范围；问题出现的原因；排查的过程；如何解决的；解决人；解决时间点；
    2、扩展项：是不是共性问题，有哪些时可以被其他项目借鉴的；如何避免类似情况的发生；有没有更好的解决方案；
  ~~~
  
- 系统思维
  ~~~
  学习应该，形成体系，将知识结构化。
  零散的知识点，不方便记忆。应该找到规律，结构化，标准化，系统化。
  
  对于第三方库的学习，不能只停留在对api对应用级别：
    1、了解底层原理
    2、社区配置（文档）；社区更新力度；问题支持力度
    3、应用场景，解决的问题
    4、有何利弊
    5、可扩展性；
    6、落地的复杂度，学习成本
  ~~~
- 创新思维
  ~~~
  保持好奇心，了解行业技术最新动态，尝试在实际项目中应用。
  
  一个问题，多套方案，养成思考最优解对思维
  ~~~
- 问题思维
  ~~~
  问题无关大小，都应重视。问题小的，发生在体量大的系统上，也会产生不良的影响。
  
  问题的出现，意味着机会，解决问题才能体现价值。
  ~~~
- 观察思维
  ~~~
  了解行业的业务经营模式，分析背后盈利模式；
  
  通过简历招聘，了解行业的需求。
    1、性能；
    2、可视化
    3、组件化
    4、技术栈
  
  通过面试题，了解行业的关注点，技术方面应该优先掌握的技术点
  
  参加活动分享，了解行业的趋势、体系建设等
  
  
  ~~~
- 故事思维
  ~~~
  如何将自己的价值，更好的展示给别人。
  只会闷头做事的人，就是个苦力。
  ~~~
  
- 任何一个有一定复杂度、会持续增长的应用最重视的，其实并不是开发速度，而是可维护性和可扩展性。


~~~
[](https://mp.weixin.qq.com/s?__biz=MzIyMDkwODczNw==&mid=2247484581&idx=1&sn=d8cd6d87e71c0f31db2ad6e3e665dbf6&chksm=97c5990ba0b2101d26cccf583608b5ad556c193123f9e30001000c809a8f368ba69e122968c1&scene=21#wechat_redirect)
跟对老板比做对事情重要：好的老板愿意去培养下属，指出问题。有能力的老板才能给下属更高的成长空间。

不用试图耍心机或者邀功、抢功：这些伎俩只能欺骗你自己，老板视角看的一清二楚。

认真记下老板的建议，多多反思：几乎所有人接受到批评，第一反应都是去反驳。但在职场上，老板一般是不会害你的（因为有晋升等利益相关）。
这可能就是老板比你更懂你的地方，他能从一个更有经验的外部视角来看你的方案你做的事情。

遇到“不公”先想想自己：机会是有限的，为什么老板会把晋升机会、好的工作机会给某个人而不是你？先不要抱怨不公，想想为什么。

抓住机会多跟老板交流：基本上每周周会上，我都会提出来一些手头上一些比较棘手的问题或者对团队未来新动向的疑问，
来学习下老板是什么样的解决思路。


不要经常换工作，做一份工作通常 3-4 年才会有所沉淀，对这个领域非常了解。 换工作的原因一定是追求更高的目标，而不是工作中遇到了困难想要逃避或者追求涨薪。
越是遇到困难越要解决困难才可能有成长，逃避困难，换了工作仍然会遇到。技术的深度会跟薪资挂钩正比，即便是通过跳槽涨薪，没有技术实力压住泡沫还是会破。

在 IT 行业，工作和兴趣要尽可能贴合，可以发挥最大效果。 假如工作内容是一条线，兴趣是是一条线，这两条线的夹角越小，干活又轻松成果又多。
如果这两条线是直角，两边可能都很痛苦，建议调整。

牛逼的架构师一定是业务、前后端各种技术栈全部有很深的理解。 不懂业务或者不懂前端只懂后端，
都很难站在一个更高的视角来整体看问题和设计架构。因为系统是一个整体，有一部分不懂或者不关心，就可能成为系统的短板。


如何能评估比较准的工期呢？一个很简单的公式送给大家：
  需求非常明确而且经常这样做：自己评估时间 * 1.5
  需求不够清晰，有可能变，但是代码和技术方案熟悉：自己评估的时间 * 2
  需求不够清晰，代码和技术方案也是新的，需要探索：自己评估的时间 * 2.5 or 3
  
  
ICE 最初就是基于 React 的一堆基础组件 + 业务组件 + 脚手架 + 前端教学文档 + 前端答疑群。我们的卖点就是：
 你系统里的复杂组件如果可以被其他系统复用，那么我们来开发；我们提供前端技能培训和答疑，在我们答疑群里问的任何前端问题都可以被我们解答，复杂问题我们提供上门服务
~~~
- [阿里职级体系与薪酬全曝光，P10以上都是世界大牛！]( https://mp.weixin.qq.com/s/s1r_Bcw-gwTMvY77o316_w )
- (已整理)[高龄程序员如何自处?]( https://mp.weixin.qq.com/s/ShJeSnePwpVhCLgVFjwJ-w )
~~~
怎么提高你的单位时间价值呢？
提升你的技术能力，把时间花在解决别人解决不了的难题上。
提升自己的责任感，主动去承担责任，责任往往伴随着权利，让自己成为项目组的核心。
培养自己批量解决问题的能力。过去你可能可以解决任何业务方提出的需求。但是现在需要在这基础上沉淀和总结规律，提炼出一套解决该类问题的通用解决思路和方法。
原来你只能接一个项目，现在你可以同时接多个同类的项目，也没问题了。此时你会说，我自己做不完啊！为什么要自己做？如果你完全知道怎么做，
那就跟你的老板申请加个实习生或者外包的同学来帮你写代码。关键在于，你有一套方法，可以保证质量。
提高效率。作为一个前端工程师，你需要开始写工具了。只要能让你更快完成开发任务的工具和方法，都可以提高你的单位时间价值。
复制你的时间。花一份时间完成某个事情，然后让他持续复制下去。每复制一份就能带来一份收益。知识付费了解一下。

明确你身上哪些东西是别人需要的
这个世界上只有两种商业模式，一个产品生意，一个是流量生意。一种人拿着产品寻找用户，叫产品生意，还有一种是拿着用户寻找产品的，这种叫做流量生意。

你身上有什么东西是可以卖的吗？
你的经验。把你的经验打包成产品，交付给他们。收点钱不过分。这就类似于，很多人都想去挖金子，而你以自己的经验，总结出一套方法，可以让他挖的更快，
那你的这套方法就值钱了，有多少人想淘金，你就有多少用户。
你的技能。你能解决别人解决不了的问题，这就是你的价值，这个价值只要加上简单的运营就可以换来财富。比如现在的技术咨询行业。给一个创业公司搭建一套 
DevOps 平台，你觉得难吗？但是确是很多创业公司非常需要的。你可以帮他们解决他们软件架构的性能问题，这也是你的价值。
你的不同。每个人都是不同的，你需要走出去，让更多的人认识你，提升自己的影响力，积累一部分脑残粉，让他们来供养你吧。试试去做一个 YouTuber ，
分享你自己。
~~~
- (已整理)[前端项目如何管理]( https://mp.weixin.qq.com/s/UR3Wd_6xDYExIjO6V94tQw )
  ~~~
  一般会从下面几点来考证一个项目是否管理得很好：
    可扩展性：能够很方便、清晰的扩展一个页面、组件、模块
    组件化：多个页面之间共用的大块代码可以独立成组件，多个页面、组件之间共用的小块代码可以独立成公共模块
    可阅读性：阅读性良好（包括目录文件结构、代码结构），能够很快捷的找到某个页面、组件的文件，也能快捷的看出项目有哪些页面、组件
    可移植性：能够轻松的对项目架构进行升级，或移植某些页面、组件、模块到其他项目
    可重构性：对某个页面、组件、模块进行重构时，能够保证在重构之后功能不会改变、不会产生新 bug
    开发友好：开发者在开发某一个功能时，能够有比较好的体验（不好的体验比如：多个文件相隔很远）
    协作性：多人协作时，很少产生代码冲突、文件覆盖等问题
    可交接性：当有人要离开项目时，交接给其他人是很方便的
  
  .editorconfig: 统一每个开发人员的编辑器配置
  eslint: 检查 js 语法（包括 jsx 语法），然后最大程度的矫正不符合规范的代码
  stylelint: 检查 css 语法（包括 less, scss 语法），然后最大程度的矫正不符合规范的代码
  prettier: 代码格式优化
  husky + lint-staged: 强制开发人员对代码进行检查、自动矫正与优化
  
  
  测试：
  js 模块：jest / mocha / tape / ava
  
  React 组件：enzyme + jest，另外可以使用 react-testing-library 代替 react-dom/test-utils
  
  Vue 组件：vue-test-utils + jest / mocha / tape / ava
  
  
  一般会从下面几点来考证多个项目之间是否管理得很好：
    组件化：多个项目共用的代码应当独立出来，成为一个单独的组件项目
    版本化：组件项目与应用项目都应当版本化管理，特别是组件项目的版本应当符合 semver 语义化版本规范
        版本格式：主版本号.次版本号.修订号，版本号递增规则如下：

        主版本号：当你做了不兼容的 API 修改，
        
        次版本号：当你做了向下兼容的功能性新增，
        
        修订号：当你做了向下兼容的问题修正。
        
        先行版本号及版本编译元数据可以加到“主版本号.次版本号.修订号”的后面，作为延伸。
    统一性：多个项目之间应当使用相同的技术选型、UI 框架、脚手架、开发工具、构建工具、测试库、目录规范、代码规范等，相同功能应指定使用固定某一个库
    文档化：组件项目一定需要相关的文档，应用项目在必要的时候也要形成相应的文档
  ~~~
- [代码质量管控的四个阶段](https://mp.weixin.qq.com/s/JAm3qdG-j4t_hSmn7cCfVg  )
  ~~~
  规范化 - 建立代码规范与Code Review制度
    风格规范 - 缩进、换行、大小写等风格问题

    实践规范 - 规避一些常见的隐患，或者针对特定问题的最佳实践
    
    业务规范 - 与业务有关的特殊要求，比如文案中的关键词

  自动化 - 使用工具自动检查代码质量
    代码规范检查 - 包括风格规范、实践规范、业务规范

    重复率 - 重复出现的代码区块占比，通常要求在5%以下
    
    复杂度 - 总行数，模块大小，循环复杂度等
    
    检查覆盖度 - 经过检查的行数占代码库总行数的比例
  
  流程化 - 将代码质量检查与代码流动过程绑定
    执行自动化代码质量检查的时机：
      编辑时 - 使用编辑器插件，实时运行质量检查
      
      构建时 - 在本地或者开发机的构建脚本中运行质量检查
      
      提交时 - 利用Git Hooks，提交代码或者生成Pull Request时运行质量检查
      
      发布时 - 在发布脚本中再做一次质量检查，通常与自动化测试放在一起
  
  中心化 - 以团队整体为视角，集中管理代码规范，并实现质量状况透明化
  
    当团队规模越来越大，项目越来越多时，代码质量管控就会面临以下问题：
      不同项目使用的代码规范不一样
      部分项目由于放松要求，没有接入质量检查，或者存在大量未修复的缺陷
      无法从团队整体层面上体现各个项目的质量状况对比
    
    为了应对以上问题，需要建设中心化的代码质量管控体系，要点包括：
      代码规范统一管理。使用Git或者NPM包管理自动化代码质量检查的规则集，自动安装，不在本地写规则。一个团队、
      一类项目、一套规则。
      
      使用统一的持续集成服务。质量检查不通过的项目不能上线。
      
      建立代码质量评分制度。让项目与项目之间能够横向对比，项目自身能够纵向对比，并且进行汇总反馈。
  ~~~
- [2019-2020中国互联网趋势报告]( https://mp.weixin.qq.com/s/kcqhbqlUO4QYIOsAcpyPjg )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )

- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )