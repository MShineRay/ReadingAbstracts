# 性能优化

### vue相关
- vue打包文件分析
  - package.json
    ~~~
    "scripts": {
      "report": "vue-cli-service build --report", // 单次构建分析，查看/dist/report.html
      "analyse": "cross-env Analyse=true  vue-cli-service build",// 推荐：实时分析
    }
    ~~~
  - vue.config.js
    ~~~
      npm i -D webpack-bundle-analyzer
    ~~~
    ~~~      
    const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin
    
    configureWebpack: (config) => {
      if (process.env.Analyse) {
        config.plugins.push(new BundleAnalyzerPlugin())
      }
    }
    ~~~
  - cdn
    - 在 index.html 中引入公共包 js
      ~~~
      1、公司cdn
      2、公网cdn
          <script rel="preconnect" src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.min.js" type="text/javascript"></script>
          <script rel="preconnect" src="https://cdn.jsdelivr.net/npm/vue-router@3.5.3/dist/vue-router.min.js" type="text/javascript"></script>
          <script rel="preconnect" src="https://cdn.jsdelivr.net/npm/vue-i18n@8.25.0/dist/vue-i18n.min.js" type="text/javascript"></script>
          <script rel="preconnect" src="https://cdn.jsdelivr.net/npm/element-ui@2.15.6/lib/index.js" type="text/javascript"></script>
          <script rel="preconnect" src="https://cdn.jsdelivr.net/npm/axios@0.19.2/dist/axios.min.js" type="text/javascript"></script>
          <script rel="preconnect" src="https://cdn.jsdelivr.net/npm/mathjs@10.0.0/lib/browser/math.js" type="text/javascript"></script>
      ~~~
    -  vue.config.js
      ~~~
      const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin
      
      configureWebpack: (config) => {
        config.externals = {
            // key：vue是项目里引入时候要用的，value：是开发依赖库的主人定义的不能修改
            'vue': 'Vue',
            'vue-router': 'VueRouter',
            'vuex': 'Vuex',
            'axios': 'axios',
            "vuetify": "vuetify",
            "moment": "moment",
             clipboard: 'clipboard',
            'vue-i18n': 'VueI18n',
            'element-ui': 'ELEMENT',
            'lodash': '_',
            'math': 'mathjs'
        }
      }
      ~~~
  - gzip
    - 构建.gzip
      ~~~
        npm i -D compression-webpack-plugin
      ~~~
    - vue.config.js
      ~~~
      const CompressionPlugin = require('compression-webpack-plugin');

      configureWebpack: (config) => {
        config.plugins = [
          ...config.plugins,
          new  CompressionPlugin({
          test: /\.js$|\.html$|\.css/,
          threshold: 10240,
          deleteOriginalAssets: false
          })
        ]
      }
      ~~~
    - nginx gzip 配置
  - 打包去掉console.log
    - install babel-plugin-transform-remove-console
      ~~~
      npm install babel-plugin-transform-remove-console --save-dev
      ~~~
    - babel.config.js
      ~~~
        let plugins = []
        if (process.env.NODE_ENV === 'production') {
          plugins.push("transform-remove-console")
        }
        module.exports = {
          presets: ["@vue/app"],
          plugins
        }
      ~~~


### cdn
~~~
CDN会把源站的资源缓存到CDN服务器，当用户访问的时候就会从最近的CDN服务器拿取资源而不是从源站拿取，这样做的好处是分散了压力，同时也会提升返回访问速度和稳定性。
~~~

### gzip
~~~
nginx实现资源压缩的原理是通过ngx_http_gzip_module模块拦截请求，并对需要做gzip的类型做gzip压缩，该模块是默认基础的，不需要重新编译，直接开启即可。
~~~
- nginx gzip
  ~~~
  server {
   gzip on;
   gzip_buffers 4 16K;
   gzip_comp_level 5;
   gzip_min_length 100k;
   gzip_types text/plain application/x-javascript application/javascript application/json text/css application/xml text/javascript;
   gzip_disable "MSIE [1-6\]\.";
   gzip_vary on;
  }
  
  # 注意：图片不开启压缩
  
  gzip on|off; // 是否开启gzip
  gzip_min_length 100k; // 压缩的最小长度(再小就不要压缩了,意义不在)
  gzip_buffers 4 16k; // 缓冲(压缩在内存中缓冲几块? 每块多大?)   # 设置压缩所需要的缓冲区大小，以4k为单位，如果文件为7k则申请2*4k的缓冲区 
  gzip_comp_level 5; // 压缩级别(级别越高,压的越小,越浪费CPU计算资源)
  gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript;  // 对哪些类型的文件用压缩 如txt,xml,html,css,js等
  gzip_vary on|off; // 是否传输gzip压缩标志, 是否在http header中添加Vary: Accept-Encoding，建议开启
  gzip_static on|off; // nginx对于静态文件的处理模块，开启后会寻找以.gz结尾的文件，直接返回，不会占用cpu进行压缩，如果找不到则不进行压缩
  gzip_http_version 1.1; // 设置gzip压缩针对的HTTP协议版本
  ~~~
- 检测方法
  ~~~
  1.直接在浏览器通过开发者工具查看请求头、返回头等信息
  2.使用curl命令行curl -I -H"Accept-Encoding: gzip, deflate" "http://www.example.com"
  ~~~
- 开启失败常规情况
  ~~~
  1.先检查gzip_types中是否包含需要的类型

  2.如果公司存在多层缓存机制,确认每一层都开启了gzip压缩
  
  3.开启 gzip_static on,确认服务器上是否存在.gz文件
  ~~~

### debug utils

- chrome lighthouse
  ~~~
  First Contentful Paint 首屏渲染时间，Chrome会取第一个渲染出来的元素作为时间参考。

  Time to Interactive 可交互时间，从能看到能摸的时间点。
  
  Speed Index 速度指数，页面的填充速度。
  
  Total Blocking Time 从能看到能摸之间超过50ms的任务总和。
  
  Largest Contentful Paint 页面中最大的那块渲染的时间点。
  
  Cumulative Layout Shift 元素移动所累积的时间点，比如有一个absolute的元素突然从左边移到了右边。
  ~~~
- chrome network(网络)

- chrome performance(性能)
  - 火焰图
    ~~~
    分析长任务，或者找到某些无关紧要的任务把他们拆分，延后，优化使他们达到一个理想状态。
    ~~~

- chrome performance monitor面板
  ~~~
  监控内存和CPU的占用，它给出的是整体的占用数据，可以用来观察某一段代码某一个特效会不会造成性能影响。
  ~~~

### 从输入一个URL谈起
- DNS查询
  ~~~
  与服务器交互首先要进行DNS查询，得到服务器的IP地址，浏览器会首先查询自己的缓存，之后会查询本地HOSTS，如果仍然没找到会发起向DNS服务器查询的请求。
  ~~~
  - 进行DNS预查询 
    ~~~
    在文档顶部我们可以将我们即将要请求的地址的DNS预先查询，通过插入一个link标签
    <link rel="dns-prefetch" href="https://fonts.googleapis.com/">
    来告知浏览器我们将要从这个地址(通常会是存放静态资源的CDN的地址，)拉取数据了，你先查询一下，当用到的时候就可以直接拿到对应的IP。
    ~~~
- 建立HTTP(TCP)连接
  ~~~
  进行三次握手，之后会进行SSL握手(HTTPS)，SSL握手时会向服务器端确认HTTP的版本。
  ~~~
  - keep-alive
    ~~~
    由于TCP的可靠性，每条独立的TCP连接都会进行一次三次握手，从上面的Network的分析中可以得到握手往往会消耗大部分时间，真正的数据传输反而会少一些(当然取决于内容多少)。HTTP1.0和HTTP1.1为了解决这个问题在header中加入了Connection: Keep-Alive，keep-alive的连接会保持一段时间不断开，后续的请求都会复用这一条TCP，不过由于管道化的原因也会发生队头阻塞的问题。
    HTTP1.1默认开启Keep-Alive
    ~~~
  - HTTP2
    ~~~
    HTTP2相对于HTTP1.1的一个主要升级是多路复用，多路复用通过更小的二进制帧构成多条数据流，交错的请求和响应可以并行传输而不被阻塞，这样就解决了HTTP1.1时复用会产生的队头阻塞的问题，同时HTTP2有首部压缩的功能，如果两个请求首部(headers)相同，那么会省去这一部分，只传输不同的首部字段，进一步减少请求的体积。

    Nginx开启HTTP2的方式特别容易，只需要加一句http2既可开启：
    
    server {
      listen 443 ssl http2; # 加一句 http2.
      server_name domain.com;
    }
    ~~~
  
  - 缓存
    ~~~
    HTTP缓存主要分为两种，一种是强缓存，另一种是协商缓存，都通过Headers控制。
      
      Cache-Control: max-age=<seconds>
      Cache-Control: max-stale[=<seconds>]
      Cache-Control: min-fresh=<seconds>
      Cache-control: no-cache
      Cache-control: no-store
      Cache-control: no-transform
      Cache-control: only-if-cached
    
    max-age 是资源从响应开始计时的最大新鲜时间，一般响应中还会出现age标明这个资源当前的新鲜程度。
    no-cache 会让浏览器缓存这个文件到本地但是不用，Network中disable-cache勾中的话就会在请求时带上这个haader，会在下一次新鲜度验证通过后使用这个缓存。
    no-store 会完全放弃缓存这个文件。
    
    服务器响应时的Cache-Control略有不同，其中有两个需要注意下:
      public, public 表明这个请求可以被任何对象缓存，代理/CDN等中间商。
      private，private 表明这个请求只能被终端缓存，不允许代理或者CDN等中间商缓存。

    Expires是一个具体的日期，到了那个日期就会让这个缓存失活，优先级较低，存在max-age的情况下会被忽略，和本地时间绑定，修改本地时间可以绕过。
    另外，如果你的服务器的返回内容中不存在Expires，Cache-Control: max-age，或 Cache-Control:s-maxage但是存在Last-Modified时，那么浏览器默认会采用一个启发式的算法，即启发式缓存。通常会取响应头的Date_value - Last-Modified_value值的10%作为缓存时间，之后浏览器仍然会按强缓存来对待这个资源一段时间，如果你不想要缓存的话务必确保有no-cache或no-store在响应头中。

    ~~~
    - 强缓存
      ~~~
      强缓存根据请求头的Expires和Cache-Control判断是否命中强缓存，命中强缓存的资源直接从本地加载，不会发起任何网络请求。
      ~~~
    - 协商缓存
      ~~~
      协商缓存一般会在强缓存新鲜度过期后发起，向服务器确认是否需要更新本地的缓存文件，如果不需要更新，服务器会返回304否则会重新返回整个文件。
      
      服务器响应中会携带ETag和Last-Modified，Last-Modified 表示本地文件最后修改日期，浏览器会在request header加上If-Modified-Since（上次返回的Last-Modified的值），询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来。

      但是如果在本地打开缓存文件，就会造成Last-Modified被修改，所以在HTTP / 1.1 出现了ETag。
      
      Etag就像一个指纹，资源变化都会导致ETag变化，跟最后修改时间没有关系，ETag可以保证每一个资源是唯一的
      
      If-None-Match的header会将上次返回的ETag发送给服务器，询问该资源的ETag是否有更新，有变动就会发送新的资源回来
      
      ETag(If-None-Match)的优先级高于Last-Modified(If-Modified-Since)，优先使用ETag进行确认。
      
      协商缓存比强缓存稍慢，因为还是会发送请求到服务器进行确认。

      ~~~
  - cdn
  - 压缩
  
- 进行页面渲染    
  - 预加载/预连接内容 preload
    ~~~
      使用link的preload属性预加载一个资源。
      <link rel="preload" href="style.css" as="style">
      as属性可以指定预加载的类型，除了style还支持很多类型，常用的一般是style和script，css和js。
    ~~~
  - prefetch
    ~~~
    prefetch是一个低优先级的获取，通常用在这个资源可能会在用户接下来访问的页面中出现的时候。

    当然对当前页面的要用preload，不要用prefetch，可以用到的一个场景是在用户鼠标移入a标签时进行一个prefetch。
    ~~~
  - preconnect
    preconnect和dns-prefetch做的事情类似，提前进行TCP，SSL握手，省去这一部分时间，基于HTTP1.1(keep-alive)和HTTP2(多路复用)的特性，都会在同一个TCP链接内完成接下来的传输任务。
  - script加标记
    - async
      ~~~
      <script src="main.js" async>
      async标记告诉浏览器在等待js下载期间可以去干其他事，当js下载完成后会立即(尽快)执行，多条js可以并行下载。

      async的好处是让多条js不会互相等待，下载期间浏览器会去干其他事(继续解析HTML等)，异步下载，异步执行。
      ~~~
    - defer
      ~~~
      与async一样，defer标记告诉浏览器在等待js下载期间可以去干其他事，多条js可以并行下载，不过当js下载完成之后不会立即执行，而是会等待解析完整个HTML之后在开始执行，而且多条defer标记的js会按照顺序执行
        <script src="main.js" defer></script>
        <script src="main2.js" defer></script>
      即使main2.js先于main.js下载完成也会等待main.js执行完后再执行。
      ~~~ 
    ~~~
    async无法保证顺序且下载完就会执行而defer则会等待整个HTML解析之后才会开始执行，并且按照插入的顺序执行。
    如果两个script之间没有依赖关系并且可以尽快执行的更加适合使用async，反之如果两个script之间有依赖关系，或者希望优先解析HTML，则defer更加适合。
    ~~~  
  - 视窗外的内容懒加载
    ~~~
    视窗外的内容是不会被用户立即看到的，这时加载过多的内容反而拖慢了网站整体的渲染，我们就可以用懒加载推迟这部分内容的加载来达到加速可访问和可交互性的目的，等用户即将到达视窗内的时候再开始加载这部分内容，通常懒加载会与loading和骨架屏等技术搭配使用。
    ~~~
  - 减少无意义的回流
    ~~~
    当浏览器大小改变/滚动，DOM增删，元素尺寸或者位置发生改变时都会发生回流，回流意味着浏览器要重新计算当前页面的与之相关的所有元素，重新进行整体的布局。
    ~~~
  - 图片视频选择合理的尺寸
    ~~~
    分辨率越高的图片显示出来越消耗性能，当然带来的好处是更加的清晰，但很多情况下清晰并不是一个特别重要的标准，我们可以牺牲一部分清晰度来让图片视频体积更小，通常PC使用1倍图，移动端使用2倍图就够了，原图可以结合懒加载等待空闲或者主动触发时在加载，像是微信QQ等聊天时发的表情包一样，都是点开才会加载原图。
    ~~~
    
### Tree-shaking
~~~
Tree-shaking指的是消除没被引用的模块代码，减少代码体积大小，以提高页面的性能
webpack2加入对Tree-shaking的支持，webpack4中Tree-shaking默认开启，Tree-shaking基于ESModule静态编译而成，所以如果想要生效，在写代码的时候注意不要用CommonJS的模块，同时也要注意不要让babel给编译成CommonJS的形式。
Tree-shaking连带的有一个sideEffects的概念，因为Js的特性使得完全静态分析是一个很难的事情，很多代码往往会带有副作用，比如一下代码:

class Handler {
    handleEvent() {
        console.log('You called me.')
    }
}

window.addEventListener('visibilitychange', new Handler())

在上面的代码中不存在任何显式的调用handleEvent，但当visibilitychange发生时Js会去调用handleEvent，这个类就属于有副作用的一种，它是不能被抖掉的代码（实际上webpack也不会对类有啥想法）。
如果你确定某个文件是这种含有副作用的文件，可以在package.json中添加sideEffects: ['class.js']让webpack强行打包进去。


对于一些第三方库来说为了兼容性考虑通常入口文件都是CommonJS的形式，这时想要成功抖掉不需要的部分通常有两种方式。

以出镜率极高的lodash为例。
lodash默认是CommonJS的形式，使用常规的方法import { cloneDeep } from 'lodash'导入后，webpack会把整个lodash打包进来，这对于只用到了一个函数的我们的来说显然不可接受，此时可以改写为：
import cloneDeep from 'lodash/cloneDeep'
或者如果提供了ESModule的版本也可以直接使用:
import { cloneDeep } from 'lodash-es
前者是精准导入不依赖re-exports，后者则是一个正经的Tree-shaking

~~~

### 压缩

### 使用动态import()代替静态import做条件渲染的懒加载

### SSR
~~~
利用服务器端优先渲染出某一部分重要的内容，让其他内容懒加载，这样到达浏览器端时一部分HTML已经存在，页面上就可以呈现出一定的内容，这里注意服务器端渲染出来的HTML部分最好不要超过14kb，TCP慢开始的规则让第一个TCP包的大小是14kb，这是与网站交互会接受到的第一个包。
~~~


### 观点
~~~
传统Web都是通过服务端进行页面的可用性监控（比如服务异常、流量下降），但距离用户真实看到正常页面展现，期间的网络、前端渲染等是传统Web的性能监控运维的盲点。
~~~
~~~
针对单页面首次加载速度较慢的问题，对单页面应用进行了优化，使用了Vue ssr、数据请求并行、缓存、按需分块加载、预加载、PWA等等优化策略。解决单页面存在的“痛点”问题，大幅度减少了单页应用的首屏呈现时间。
~~~
~~~
从产品方案，交互体验，性能监控等完整生态链建设多维度拓展性能优化的手段和建议，一切性能优化的最终目的都是用户体验优化。
~~~


### reference
- [vue-cli3 webpack 打包优化]( https://segmentfault.com/a/1190000021444697 )
- [你知道的前端优化手段](https://juejin.cn/post/6966857691381645325)
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )

- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )

- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )

- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
- [](  )
