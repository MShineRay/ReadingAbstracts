<!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Title</title>
        </head>
        <body>
        
                    

                    
                    
                    
                    <p style="box-sizing: inherit;margin-top: 20px;margin-bottom: 1rem;word-wrap: break-word;font-size: 16px;line-height: 27px;color: rgb(55, 58, 60);">在
 2017年，保证页面快速加载的手段涵盖了方方面面，从压缩和资源优化，到缓存，CDN，代码分割以及 tree shaking 等。 
然而，即便你不熟悉上面的这些概念，或者你感到无从下手，你仍然可以通过几个关键字以及精细的代码结构使得你的页面获得巨大的性能提升。</p><p style="box-sizing: inherit;margin-top: 20px;margin-bottom: 1rem;word-wrap: break-word;font-size: 16px;line-height: 27px;color: rgb(55, 58, 60);">新的 Web 标准&nbsp;<code style="box-sizing: inherit;">&lt;link rel="preload"&gt;</code>使
你能够更快地加载关键资源，这个月晚些时候，Firefox 就会支持这个特性。同时在&nbsp;Firefox 
Nightly&nbsp;版本或者&nbsp;开发者版本&nbsp;上已经可以使用这些功能。与此同时，这也是回顾基本原理，深入了解 DOM 
解析相关性能的一个好时机。</p><p style="box-sizing: inherit;margin-top: 20px;margin-bottom: 1rem;word-wrap: break-word;font-size: 16px;line-height: 27px;color: rgb(55, 58, 60);">理解浏览器的内部机制是每个 web 开发者最强有力的工具。我们看看浏览器是如何解释代码以及如何使用推测解析（speculative parsing）来帮助页面快速加载的。我们会分析&nbsp;<code style="box-sizing: inherit;">defer</code>&nbsp;和&nbsp;<code style="box-sizing: inherit;">async</code>&nbsp;是如何生效的以及如何利用新的关键字&nbsp;<code style="box-sizing: inherit;">preload</code>。</p><h2 style="box-sizing: inherit;margin-top: 20px;margin-bottom: 0.5rem;"><strong><span style="font-size: 20px;">构建模块</span></strong></h2><p style="box-sizing: inherit;margin-top: 20px;margin-bottom: 1rem;word-wrap: break-word;font-size: 16px;line-height: 27px;color: rgb(55, 58, 60);">HTML
 描述了一个页面的结构。为了理解 HTML，浏览器首先会将HTML转换成其能够理解的一种格式 –&nbsp;文档对象模型（Document 
Object Model）&nbsp;或者简称为 DOM。 
浏览器引擎有这么一段特殊的代码叫做解析器，用来将数据从一种格式转换成另外一种格式。一个 HTML 解析器就能将数据从 HTML 转换到 DOM。</p><p style="box-sizing: inherit;margin-top: 20px;margin-bottom: 1rem;word-wrap: break-word;font-size: 16px;line-height: 27px;color: rgb(55, 58, 60);">在 HTML 当中，嵌套（nesting）定义了不同标签的父子关系。在 DOM 当中，对象被关联在树（一种数据结构）中用于捕获这些关系。每一个 HTML 标签都对应着树种的某个节点（DOM节点）。</p><p style="box-sizing: inherit;margin-top: 20px;margin-bottom: 1rem;word-wrap: break-word;font-size: 16px;line-height: 27px;color: rgb(55, 58, 60);">浏览器一个比特一个比特地构建 DOM。一旦第一个代码块加载到浏览器当中，它就开始解析 HTML，添加节点到树中。</p><p style="box-sizing: inherit;margin-top: 20px;margin-bottom: 1rem;word-wrap: break-word;font-size: 16px;line-height: 27px;color: rgb(55, 58, 60);"><img data-src="http://mmbiz.qpic.cn/mmbiz_gif/1NOXMW586uv2pLFk6NGPvhqxgVLiaVciczGJ27MiaDDNlflVHbsKUmVbE9OStZUIn2a1fiaXb4U2R7csqzV688uK0w/0?wx_fmt=gif" style="box-sizing: inherit; border-style: none; vertical-align: middle; margin-top: 1rem; margin-bottom: 1rem; width: 600px !important; height: auto !important; visibility: visible !important;" class="__bg_gif" data-ratio="0.33666666666666667" data-w="600" data-type="gif" _width="600px" src="%E6%9B%B4%E5%BF%AB%E5%9C%B0%E6%9E%84%E5%BB%BA%20DOM%20%E4%BD%BF%E7%94%A8%E9%A2%84%E8%A7%A3%E6%9E%90async,%20defer%20%E4%BB%A5%E5%8F%8A%20preload_files/0.gif" data-order="0" alt="图片" data-fail="0"></p><p style="box-sizing: inherit;margin-top: 20px;margin-bottom: 1rem;word-wrap: break-word;font-size: 16px;line-height: 27px;color: rgb(55, 58, 60);">DOM 扮演着两种角色：它既是 HTML 文档的对象表示，也充当着外界（比如JavaScript）和页面交互的接口。 当你调用&nbsp;<code style="box-sizing: inherit;">document.getElementById()</code>，返回的元素是一个 DOM 节点。每个 DOM 节点都有很多函数可以用来访问和改变它，用户可以看到相应的变化。</p><p style="box-sizing: inherit;margin-top: 20px;margin-bottom: 1rem;word-wrap: break-word;font-size: 16px;line-height: 27px;color: rgb(55, 58, 60);"><img data-src="http://mmbiz.qpic.cn/mmbiz_gif/1NOXMW586uv2pLFk6NGPvhqxgVLiaVciczjzicZ7bQIo5v0j8ldSE8U4DLqdF0Pz0BibbpNnwJUuZNibJFvADHxUxdg/0?wx_fmt=gif" style="box-sizing: inherit; border-style: none; vertical-align: middle; margin-top: 1rem; margin-bottom: 1rem; width: 595px !important; height: 229px !important;" class="img_loading __bg_gif" data-ratio="0.38487394957983195" data-w="595" data-type="gif" _width="595px" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" data-order="1" alt="图片"></p><p style="box-sizing: inherit;margin-top: 20px;margin-bottom: 1rem;word-wrap: break-word;font-size: 16px;line-height: 27px;color: rgb(55, 58, 60);">页
面上的 CSS 样式被映射到 CSSOM 上 –&nbsp;CSS 对象模型（CSS Object Model）。它就像 DOM，但是只针对于 
CSS 而不是 HTML。不像 DOM，它不能增量地构建。因为 CSS 规则会相互覆盖，所以浏览器引擎要进行复杂的计算来确定 CSS 
代码如何应用到 DOM 上。</p><p style="box-sizing: inherit;margin-top: 20px;margin-bottom: 1rem;word-wrap: break-word;font-size: 16px;line-height: 27px;color: rgb(55, 58, 60);"><img data-src="http://mmbiz.qpic.cn/mmbiz_png/1NOXMW586uv2pLFk6NGPvhqxgVLiaVciczqFOSADbQUiaJovWZqDtrLX682pOdRrq4oKgibMvzmicuPZiaibTT8XCk32w/0?wx_fmt=png" style="box-sizing: inherit; border-style: none; vertical-align: middle; margin-top: 1rem; margin-bottom: 1rem; width: 500px !important; height: 126px !important;" class="img_loading" data-ratio="0.252" data-w="500" data-type="png" _width="500px" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" crossorigin="anonymous" alt="图片"></p><h2 style="box-sizing: inherit;margin-top: 20px;margin-bottom: 0.5rem;"><strong><span style="font-size: 20px;">关于</span><code style="box-sizing: inherit;"><span style="font-size: 20px;">&lt;script&gt;</span></code><span style="font-size: 20px;">标签的历史</span></strong></h2><p style="box-sizing: inherit;margin-top: 20px;margin-bottom: 1rem;word-wrap: break-word;font-size: 16px;line-height: 27px;color: rgb(55, 58, 60);">当浏览器构建 DOM 的时候，如果在 HTML 中遇到了一个&nbsp;<code style="box-sizing: inherit;">&lt;script&gt;...&lt;/script&gt;</code>标签，它必须立即执行。如果脚本是来自于外部的，那么它必须首先下载脚本。</p><p style="box-sizing: inherit;margin-top: 20px;margin-bottom: 1rem;word-wrap: break-word;font-size: 16px;line-height: 27px;color: rgb(55, 58, 60);">在过去，为了执行一个脚本，HTML 的解析必须暂停。只有在 JavaScript 引擎执行完代码之后它才会重新开始解析。</p><p style="box-sizing: inherit;margin-top: 20px;margin-bottom: 1rem;word-wrap: break-word;font-size: 16px;line-height: 27px;color: rgb(55, 58, 60);"><img data-src="http://mmbiz.qpic.cn/mmbiz_png/1NOXMW586uv2pLFk6NGPvhqxgVLiaVcicz0BHJj3VXl6ziaMxzxSCpuaJics1zQMicBicWEfKiaSnicVT4RiaOLPW4wJNsQ/0?wx_fmt=png" style="box-sizing: inherit; border-style: none; vertical-align: middle; margin-top: 1rem; margin-bottom: 1rem; width: 500px !important; height: 150px !important;" class="img_loading" data-ratio="0.3" data-w="500" data-type="png" _width="500px" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" crossorigin="anonymous" alt="图片"></p><p style="box-sizing: inherit;margin-top: 20px;margin-bottom: 1rem;word-wrap: break-word;font-size: 16px;line-height: 27px;color: rgb(55, 58, 60);">那位为什么解析必须要暂停呢？那是因为脚本可以改变 HTML以及它的产物 —— DOM。 脚本可以通过&nbsp;<code style="box-sizing: inherit;">document.createElement()</code>方法添加节点来改变 DOM 结构。为了改变 HTML，脚本可以使用臭名昭著的<code style="box-sizing: inherit;">document.write()</code>方法来添加内容。它之所以臭名昭著是因为它能以进一步影响 HTML 解析的方式来改变 HTML。比如，该方法可以插入一个打开的注释标签来使得剩余的 HTML 都变得不合法。</p><p style="box-sizing: inherit;margin-top: 20px;margin-bottom: 1rem;word-wrap: break-word;font-size: 16px;line-height: 27px;color: rgb(55, 58, 60);"><img data-src="http://mmbiz.qpic.cn/mmbiz_gif/1NOXMW586uv2pLFk6NGPvhqxgVLiaVciczdveBF8uUQvEhsfmIPj6wYU0DicF40PKiaCKuib0JicskF2z3TDTd7OazEA/0?wx_fmt=gif" style="box-sizing: inherit; border-style: none; vertical-align: middle; margin-top: 1rem; margin-bottom: 1rem; width: 500px !important; height: 200px !important;" class="img_loading __bg_gif" data-ratio="0.4" data-w="500" data-type="gif" _width="500px" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" data-order="2" alt="图片"></p><p style="box-sizing: inherit;margin-top: 20px;margin-bottom: 1rem;word-wrap: break-word;font-size: 16px;line-height: 27px;color: rgb(55, 58, 60);">脚本还可以查询关于 DOM 的一些东西，如果是在 DOM 还在在构建的时候，它可能会返回意外的结果。</p><p style="box-sizing: inherit;margin-top: 20px;margin-bottom: 1rem;word-wrap: break-word;font-size: 16px;line-height: 27px;color: rgb(55, 58, 60);"><img data-src="http://mmbiz.qpic.cn/mmbiz_png/1NOXMW586uv2pLFk6NGPvhqxgVLiaVciczYI3uibQwwDo1nibSG9RUFxRofqw37k4z8EOvfv01TnMIRowv4GYib2D4A/0?wx_fmt=png" style="box-sizing: inherit; border-style: none; vertical-align: middle; margin-top: 1rem; margin-bottom: 1rem; width: 500px !important; height: 217px !important;" class="img_loading" data-ratio="0.434" data-w="500" data-type="png" _width="500px" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" crossorigin="anonymous" alt="图片"></p><p style="box-sizing: inherit;margin-top: 20px;margin-bottom: 1rem;word-wrap: break-word;font-size: 16px;line-height: 27px;color: rgb(55, 58, 60);"><code style="box-sizing: inherit;">document.write()</code>&nbsp;是一个遗留的方法，它能够以预料之外的方式破坏你的页面，你应该避免使用它。处于这些原因，浏览器开发出了一些复杂的方法来应对脚本阻塞导致的性能问题，稍后我会解释。</p><h2 style="box-sizing: inherit;margin-top: 20px;margin-bottom: 0.5rem;"><span style="font-size: 20px;"><strong>那么 CSS 会阻塞页面吗 ？</strong></span></h2><p style="box-sizing: inherit;margin-top: 20px;margin-bottom: 1rem;word-wrap: break-word;font-size: 16px;line-height: 27px;color: rgb(55, 58, 60);">JavaScript 阻塞页面解析是因为它可以修改文档。CSS 不能修改文档，所以看起来它没有理由去阻塞页面解析，对吗？</p><p style="box-sizing: inherit;margin-top: 20px;margin-bottom: 1rem;word-wrap: break-word;font-size: 16px;line-height: 27px;color: rgb(55, 58, 60);">那么，如果脚本需要样式信息，但样式还没有被解析呢？浏览器并不知道脚本要怎么执行——它可能会需要类似 DOM 节点的<code style="box-sizing: inherit;">background-color</code>&nbsp;属性，而这个属性又依赖于样式表，或者它期望能够直接访问 CSSOM。</p><p style="box-sizing: inherit;margin-top: 20px;margin-bottom: 1rem;word-wrap: break-word;font-size: 16px;line-height: 27px;color: rgb(55, 58, 60);"><img data-src="http://mmbiz.qpic.cn/mmbiz_png/1NOXMW586uv2pLFk6NGPvhqxgVLiaVciczCfJJud7Ff4YRqPMtDKldOicBnWD5020XJYVISSxZw1F3CHIFZv5MHcA/0?wx_fmt=png" style="box-sizing: inherit; border-style: none; vertical-align: middle; margin-top: 1rem; margin-bottom: 1rem; width: 500px !important; height: 302px !important;" class="img_loading" data-ratio="0.604" data-w="500" data-type="png" _width="500px" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" crossorigin="anonymous" alt="图片"></p><p style="box-sizing: inherit;margin-top: 20px;margin-bottom: 1rem;word-wrap: break-word;font-size: 16px;line-height: 27px;color: rgb(55, 58, 60);">正
因为如此，CSS 可能会阻塞解析，取决于外部样式表和脚本在文档中的顺序。如果在文档中外部样式表放置在脚本之前，DOM 对象和 CSSOM 
对象的构建可以互相干扰。 当解析器获取到一个 script 标签，DOM 将无法继续构建直到 JavaScript 执行完毕，而 
JavaScript 在 CSS 下载完，解析完，并且 CSSOM 可以使用的时候，才能执行。</p><p style="box-sizing: inherit;margin-top: 20px;margin-bottom: 1rem;word-wrap: break-word;font-size: 16px;line-height: 27px;color: rgb(55, 58, 60);"><img data-src="http://mmbiz.qpic.cn/mmbiz_png/1NOXMW586uv2pLFk6NGPvhqxgVLiaVciczTWogGia0KsQbkpyJRM70WkiaZwMaRgvTRZM4JJbZyUVlNAMmFS7pyWLA/0?wx_fmt=png" style="box-sizing: inherit; border-style: none; vertical-align: middle; margin-top: 1rem; margin-bottom: 1rem; width: 500px !important; height: 162px !important;" class="img_loading" data-ratio="0.324" data-w="500" data-type="png" _width="500px" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" crossorigin="anonymous" alt="图片"></p><p style="box-sizing: inherit;margin-top: 20px;margin-bottom: 1rem;word-wrap: break-word;font-size: 16px;line-height: 27px;color: rgb(55, 58, 60);">另
外一件要注意的事是，即使 CSS 不阻塞 DOM 的构建，它也会阻塞 DOM 的渲染。直到 DOM 和 CSSOM 
准备好之前，浏览器什么都不会显示。这是因为页面没有 CSS 通常无法使用。如果一个浏览器给你显示了一个没有 CSS 
的凌乱的页面，而几分钟之后又突然变成了一个有样式的页面，变换的内容和突然视觉变化使得用户体验变得非常糟糕。</p><p style="box-sizing: inherit;margin-top: 20px;margin-bottom: 1rem;word-wrap: break-word;font-size: 16px;line-height: 27px;color: rgb(55, 58, 60);"><em style="box-sizing: inherit;">这种糟糕的用户体验有一个名字 — Flash of Unstyled Content 或是 FOUC</em></p><p style="box-sizing: inherit;margin-top: 20px;margin-bottom: 1rem;word-wrap: break-word;font-size: 16px;line-height: 27px;color: rgb(55, 58, 60);">为了避免这个问题，你应该尽快地呈现 CSS。记得流行的“样式放顶部，脚本放底部”的最佳实践吗？你现在知道它是怎么来的了！</p><h2 style="box-sizing: inherit;margin-top: 20px;margin-bottom: 0.5rem;"><span style="font-size: 20px;"><strong>回到未来 – 预解析（speculative parsing)</strong></span></h2><p style="box-sizing: inherit;margin-top: 20px;margin-bottom: 1rem;word-wrap: break-word;font-size: 16px;line-height: 27px;color: rgb(55, 58, 60);">每当解析器遇到一个脚本就暂停意味着每个你加载的脚本都会推迟发现链接到 HTML 的其他资源。</p><p style="box-sizing: border-box;margin-top: 1.5em;margin-bottom: 1.5em;font-size: 16px;color: rgb(62, 62, 62);line-height: inherit;white-space: normal;background-color: rgb(255, 255, 255);">如果你有几个类似的脚本和图片要加载，例如：</p><pre style="box-sizing: border-box;margin-top: 0px;margin-bottom: 0px;padding: 0px;font-size: 16px;color: rgb(62, 62, 62);line-height: inherit;background-color: rgb(255, 255, 255);"><code class="" style="box-sizing: border-box;padding: 0.5em;font-size: 14px;color: rgb(131, 148, 150);line-height: 18px;font-family: Consolas, Inconsolata, Courier, monospace;display: block;overflow-x: auto;letter-spacing: 0px;background: rgb(0, 43, 54);word-wrap: normal !important;word-break: normal !important;overflow-y: auto !important;"><span class="" style="box-sizing: border-box;font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;white-space: inherit !important;">&lt;<span class="" style="box-sizing: border-box;font-size: inherit;color: rgb(38, 139, 210);line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;white-space: inherit !important;">script</span> <span class="" style="box-sizing: border-box;font-size: inherit;color: rgb(181, 137, 0);line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;white-space: inherit !important;">src</span>=<span class="" style="box-sizing: border-box;font-size: inherit;color: rgb(42, 161, 152);line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;white-space: inherit !important;">"slider.js"</span>&gt;</span><span class="" style="box-sizing: border-box;font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;white-space: inherit !important;"></span><span class="" style="box-sizing: border-box;font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;white-space: inherit !important;">&lt;/<span class="" style="box-sizing: border-box;font-size: inherit;color: rgb(38, 139, 210);line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;white-space: inherit !important;">script</span>&gt;</span><br style="box-sizing: border-box;font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;white-space: inherit !important;"><span class="" style="box-sizing: border-box;font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;white-space: inherit !important;">&lt;<span class="" style="box-sizing: border-box;font-size: inherit;color: rgb(38, 139, 210);line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;white-space: inherit !important;">script</span> <span class="" style="box-sizing: border-box;font-size: inherit;color: rgb(181, 137, 0);line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;white-space: inherit !important;">src</span>=<span class="" style="box-sizing: border-box;font-size: inherit;color: rgb(42, 161, 152);line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;white-space: inherit !important;">"animate.js"</span>&gt;</span><span class="" style="box-sizing: border-box;font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;white-space: inherit !important;"></span><span class="" style="box-sizing: border-box;font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;white-space: inherit !important;">&lt;/<span class="" style="box-sizing: border-box;font-size: inherit;color: rgb(38, 139, 210);line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;white-space: inherit !important;">script</span>&gt;</span><br style="box-sizing: border-box;font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;white-space: inherit !important;"><span class="" style="box-sizing: border-box;font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;white-space: inherit !important;">&lt;<span class="" style="box-sizing: border-box;font-size: inherit;color: rgb(38, 139, 210);line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;white-space: inherit !important;">script</span> <span class="" style="box-sizing: border-box;font-size: inherit;color: rgb(181, 137, 0);line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;white-space: inherit !important;">src</span>=<span class="" style="box-sizing: border-box;font-size: inherit;color: rgb(42, 161, 152);line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;white-space: inherit !important;">"cookie.js"</span>&gt;</span><span class="" style="box-sizing: border-box;font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;white-space: inherit !important;"></span><span class="" style="box-sizing: border-box;font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;white-space: inherit !important;">&lt;/<span class="" style="box-sizing: border-box;font-size: inherit;color: rgb(38, 139, 210);line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;white-space: inherit !important;">script</span>&gt;</span><br style="box-sizing: border-box;font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;white-space: inherit !important;"><span class="" style="box-sizing: border-box;font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;white-space: inherit !important;">&lt;<span class="" style="box-sizing: border-box;font-size: inherit;color: rgb(38, 139, 210);line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;white-space: inherit !important;">img</span> <span class="" style="box-sizing: border-box;font-size: inherit;color: rgb(181, 137, 0);line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;white-space: inherit !important;">src</span>=<span class="" style="box-sizing: border-box;font-size: inherit;color: rgb(42, 161, 152);line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;white-space: inherit !important;">"slide1.png"</span>&gt;</span><br style="box-sizing: border-box;font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;white-space: inherit !important;"><span class="" style="box-sizing: border-box;font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;white-space: inherit !important;">&lt;<span class="" style="box-sizing: border-box;font-size: inherit;color: rgb(38, 139, 210);line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;white-space: inherit !important;">img</span> <span class="" style="box-sizing: border-box;font-size: inherit;color: rgb(181, 137, 0);line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;white-space: inherit !important;">src</span>=<span class="" style="box-sizing: border-box;font-size: inherit;color: rgb(42, 161, 152);line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;white-space: inherit !important;">"slide2.png"</span>&gt;</span><br style="box-sizing: border-box;font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;white-space: inherit !important;"></code></pre><p style="box-sizing: border-box;margin-top: 1.5em;margin-bottom: 1.5em;font-size: 16px;color: rgb(62, 62, 62);line-height: inherit;white-space: normal;background-color: rgb(255, 255, 255);">这个过程过去是这样的：</p><p style="box-sizing: inherit;margin-top: 20px;margin-bottom: 1rem;word-wrap: break-word;font-size: 16px;line-height: 27px;color: rgb(55, 58, 60);"><img data-src="http://mmbiz.qpic.cn/mmbiz_png/1NOXMW586uv2pLFk6NGPvhqxgVLiaVcicz2lpd7TaTibBnkY6j8ibHVpHw8LJV7qJZib72IMVibjrDCHJVlhG5QrHdqQ/0?wx_fmt=png" style="box-sizing: inherit; border-style: none; vertical-align: middle; margin-top: 1rem; margin-bottom: 1rem; width: 500px !important; height: 208px !important;" class="img_loading" data-ratio="0.416" data-w="500" data-type="png" _width="500px" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" crossorigin="anonymous" alt="图片"></p><p style="box-sizing: inherit;margin-top: 20px;margin-bottom: 1rem;word-wrap: break-word;font-size: 16px;line-height: 27px;color: rgb(55, 58, 60);">这
个状况在 2008 年左右改变了，当时 IE 引入了一个概念叫做 “先行下载”。 
这是一种在同步的脚步执行的时候保持文件的下载的一种方法。Firefox，Chrome 和 Safari 
随后效仿，如今大多数的浏览器都使用了这个技术，它们有着不同的名称。Chrome 和 Safari 称它为 “预扫描器” 而 Firefox 
称它为预解析器。</p><p style="box-sizing: inherit;margin-top: 20px;margin-bottom: 1rem;word-wrap: break-word;font-size: 16px;line-height: 27px;color: rgb(55, 58, 60);">它的概念是：虽然在执行脚本时构建 DOM 是不安全的，但是你仍然可以解析 HTML 来查看其它需要检索的资源。找到的文件会被添加到一个列表里并开始在后台并行地下载。当脚本执行完毕之后，这些文件很可能已经下载完成了。</p><p style="box-sizing: inherit;margin-top: 20px;margin-bottom: 1rem;word-wrap: break-word;font-size: 16px;line-height: 27px;color: rgb(55, 58, 60);">上面例子的瀑布图现在看起来是这样的：</p><p style="box-sizing: inherit;margin-top: 20px;margin-bottom: 1rem;word-wrap: break-word;font-size: 16px;line-height: 27px;color: rgb(55, 58, 60);"><img data-src="http://mmbiz.qpic.cn/mmbiz_png/1NOXMW586uv2pLFk6NGPvhqxgVLiaVciczQSJ9toQ323RibApzuPe2c8ek15hyWXia1QRJCrz5fT0uIVFYibe6RDpaw/0?wx_fmt=png" style="box-sizing: inherit; border-style: none; vertical-align: middle; margin-top: 1rem; margin-bottom: 1rem; width: 500px !important; height: 208px !important;" class="img_loading" data-ratio="0.416" data-w="500" data-type="png" _width="500px" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" crossorigin="anonymous" alt="图片"></p><p style="box-sizing: inherit;margin-top: 20px;margin-bottom: 1rem;word-wrap: break-word;font-size: 16px;line-height: 27px;color: rgb(55, 58, 60);">以这种方式触发的下载请求称之为 “预测”，因为很有可能脚本还是会改变 HTML 结构（还记得<code style="box-sizing: inherit;">document.write</code>吗？），导致了预测的浪费。虽然这是有可能的，但是却不常见，所以这就是为什么预解析仍然能够带来很大的性能提升。</p><p style="box-sizing: inherit;margin-top: 20px;margin-bottom: 1rem;word-wrap: break-word;font-size: 16px;line-height: 27px;color: rgb(55, 58, 60);">而且其他浏览器只会对链接的资源进行这样的预加载。在 Firefox 中，HTML 解析器对 DOM 树的构建也是算法预测的。有利的一面是，当推测成功的时候，就没有必要重新解析文件的一部分了。缺点是，如果推测失败了，就需要更多的工作。</p><h2 style="box-sizing: inherit;margin-top: 20px;margin-bottom: 0.5rem;"><span style="font-size: 20px;"><strong>关于（预）加载</strong></span></h2><p style="box-sizing: inherit;margin-top: 20px;margin-bottom: 1rem;word-wrap: break-word;font-size: 16px;line-height: 27px;color: rgb(55, 58, 60);">这种资源加载的方式带来了显著地性能提升，你不需要做任何事情就可以使用这种优势。然而，作为一个 web 开发者，了解预解析是如何工作的能帮你最大程度地利用它。</p><p style="box-sizing: inherit;margin-top: 20px;margin-bottom: 1rem;word-wrap: break-word;font-size: 16px;line-height: 27px;color: rgb(55, 58, 60);">可以预加载的东西在浏览器之间有所不同，但所有的主要的浏览器都会预加载：</p><ul style="" class="list-paddingleft-2"><li><p style="box-sizing: inherit;word-wrap: break-word;line-height: 27px;">脚本</p></li><li><p style="box-sizing: inherit;word-wrap: break-word;line-height: 27px;">外部 CSS</p></li><li><p style="box-sizing: inherit;word-wrap: break-word;line-height: 27px;">来自&nbsp;<code style="box-sizing: inherit;">img</code>&nbsp;标签的图片</p></li></ul><p style="box-sizing: inherit;margin-top: 20px;margin-bottom: 1rem;word-wrap: break-word;font-size: 16px;line-height: 27px;color: rgb(55, 58, 60);">Firefox 也会预加载 video 元素的&nbsp;<code style="box-sizing: inherit;">poster</code>&nbsp;属性，而 Chrome 和 Safari 会预加载&nbsp;<code style="box-sizing: inherit;">@import</code>&nbsp;规则的内联样式。</p><p style="box-sizing: inherit;margin-top: 20px;margin-bottom: 1rem;word-wrap: break-word;font-size: 16px;line-height: 27px;color: rgb(55, 58, 60);">浏
览器能够并行下载的文件的数量是有限制的。这个限制在不同浏览器之间是不同的，并且取决于不同的因素，比如：你是否从同一个服务器或是不同的服务器下载所
有的文件，又或者是你使用的是 HTTP/1.1 或是 HTTP/2 
协议。为了更快地渲染页面，浏览器对每个要下载的文件都设置优先级来优化下载。为了弄清这些的优先级，他们遵守基于资源类型、标记位置以及页面渲染的进度
的复杂方案。</p><p style="box-sizing: inherit;margin-top: 20px;margin-bottom: 1rem;word-wrap: break-word;font-size: 16px;line-height: 27px;color: rgb(55, 58, 60);">在进行预解析时，浏览不会执行内联的 JavaScript 代码块。这意味着它不会发<span style="background-color: rgb(255, 255, 255);color: rgb(62, 62, 62);">现任何的脚本注入资源，这些资源会排到抓取队列的最后面。</span></p><pre style="box-sizing: border-box;margin-top: 0px;margin-bottom: 0px;padding: 0px;font-size: 16px;color: rgb(62, 62, 62);line-height: inherit;background-color: rgb(255, 255, 255);"><code class="" style="box-sizing: border-box;padding: 0.5em;font-size: 14px;color: rgb(131, 148, 150);line-height: 18px;font-family: Consolas, Inconsolata, Courier, monospace;display: block;overflow-x: auto;letter-spacing: 0px;background: rgb(0, 43, 54);word-wrap: normal !important;word-break: normal !important;overflow-y: auto !important;"><span class="" style="box-sizing: border-box;font-size: inherit;color: rgb(133, 153, 0);line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;white-space: inherit !important;">var</span> script = <span class="" style="box-sizing: border-box;font-size: inherit;color: rgb(220, 50, 47);line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;white-space: inherit !important;">document</span>.createElement(<span class="" style="box-sizing: border-box;font-size: inherit;color: rgb(42, 161, 152);line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;white-space: inherit !important;">'script'</span>);<br style="box-sizing: border-box;font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;white-space: inherit !important;">script.src = <span class="" style="box-sizing: border-box;font-size: inherit;color: rgb(42, 161, 152);line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;white-space: inherit !important;">"//somehost.com/widget.js"</span>;<br style="box-sizing: border-box;font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;white-space: inherit !important;"><span class="" style="box-sizing: border-box;font-size: inherit;color: rgb(220, 50, 47);line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;white-space: inherit !important;">document</span>.getElementsByTagName(<span class="" style="box-sizing: border-box;font-size: inherit;color: rgb(42, 161, 152);line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;white-space: inherit !important;">'head'</span>)[<span class="" style="box-sizing: border-box;font-size: inherit;color: rgb(42, 161, 152);line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;white-space: inherit !important;">0</span>].appendChild(script);<br style="box-sizing: border-box;font-size: inherit;color: inherit;line-height: inherit;word-wrap: inherit !important;word-break: inherit !important;white-space: inherit !important;"></code></pre><p style="box-sizing: border-box;margin-top: 1.5em;margin-bottom: 1.5em;font-size: 16px;color: rgb(62, 62, 62);line-height: inherit;white-space: normal;background-color: rgb(255, 255, 255);">你应该尽可能使浏览器能更轻松访问到重要的资源。你可以把他们放到 HTML<span style="color: rgb(55, 58, 60);">标签当中或者将要加载的脚本内联到文档的前面。然而，有时候需要一些不重要的资源晚一点被加载。这种情况，你通过 JavaScript 来加载他们来避免预解析。</span></p><p style="box-sizing: inherit;margin-top: 20px;margin-bottom: 1rem;word-wrap: break-word;font-size: 16px;line-height: 27px;color: rgb(55, 58, 60);">你也可以看看这个&nbsp;MDN 指南，里面讲述了如何针对预解析优化你的页面。</p><h2 style="box-sizing: inherit;margin-top: 20px;margin-bottom: 0.5rem;"><span style="font-size: 20px;"><strong>defer 和 async</strong></span></h2><p style="box-sizing: inherit;margin-top: 20px;margin-bottom: 1rem;word-wrap: break-word;font-size: 16px;line-height: 27px;color: rgb(55, 58, 60);">不过，同步的脚本阻塞解析器仍旧是个问题。并不是所有的脚本对用户体验都是同等的重要，例如那些用于监测和分析的脚本。解决方法呢？就是去尽可能地异步加载这些不那么重要的脚本。</p><p style="box-sizing: inherit;margin-top: 20px;margin-bottom: 1rem;word-wrap: break-word;font-size: 16px;line-height: 27px;color: rgb(55, 58, 60);"><code style="box-sizing: inherit;">defer</code>&nbsp;和<code style="box-sizing: inherit;">async</code>&nbsp;属性&nbsp;提供给开发者一个方式来告诉浏览器哪些脚本是需要异步加载的。</p><p style="box-sizing: inherit;margin-top: 20px;margin-bottom: 1rem;word-wrap: break-word;font-size: 16px;line-height: 27px;color: rgb(55, 58, 60);">这两个属性都告诉浏览器，它可以 “在后台” 加载脚本的同时继续解析 HTML，并在脚本加载完之后再执行。这样，脚本下载就不会阻塞 DOM 构建和页面渲染了。结果就是，用户可以在所有的脚本加载完成之前就能看到页面。</p><p style="box-sizing: inherit;margin-top: 20px;margin-bottom: 1rem;word-wrap: break-word;font-size: 16px;line-height: 27px;color: rgb(55, 58, 60);"><code style="box-sizing: inherit;">defer</code>&nbsp;和&nbsp;<code style="box-sizing: inherit;">async</code>&nbsp;之间的不同是他们开始执行脚本的时机的不同。</p><p style="box-sizing: inherit;margin-top: 20px;margin-bottom: 1rem;word-wrap: break-word;font-size: 16px;line-height: 27px;color: rgb(55, 58, 60);"><code style="box-sizing: inherit;">defer</code>&nbsp;比&nbsp;<code style="box-sizing: inherit;">async</code>&nbsp;要先引入浏览器。它的执行在解析完全完成之后才开始，它处在<code style="box-sizing: inherit;">DOMContentLoaded</code>事件之前。 它保证脚本会按照它在 HTML 中出现的顺序执行，并且不会阻塞解析。</p><p style="box-sizing: inherit;margin-top: 20px;margin-bottom: 1rem;word-wrap: break-word;font-size: 16px;line-height: 27px;color: rgb(55, 58, 60);"><img data-src="http://mmbiz.qpic.cn/mmbiz_png/1NOXMW586uv2pLFk6NGPvhqxgVLiaVciczPvEqYWMzUexABsbwhgppWFVR3INxjAwaAtbxFD2b45eGibsWAyoIVyw/0?wx_fmt=png" style="box-sizing: inherit; border-style: none; vertical-align: middle; margin-top: 1rem; margin-bottom: 1rem; width: 500px !important; height: 164px !important;" class="img_loading" data-ratio="0.328" data-w="500" data-type="png" _width="500px" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" crossorigin="anonymous" alt="图片"></p><p style="box-sizing: inherit;margin-top: 20px;margin-bottom: 1rem;word-wrap: break-word;font-size: 16px;line-height: 27px;color: rgb(55, 58, 60);"><code style="box-sizing: inherit;">async</code>&nbsp;脚本在它们完成下载完成后的第一时间执行，它处在 window 的<code style="box-sizing: inherit;">load</code>&nbsp;事件之前。 这意味着有可能（并且很有可能）设置了 async 的脚本不会按照它们在 HTML 中出现的顺序执行。这也意味着他们可能会中断 DOM 的构建。</p><p style="box-sizing: inherit;margin-top: 20px;margin-bottom: 1rem;word-wrap: break-word;font-size: 16px;line-height: 27px;color: rgb(55, 58, 60);">无论它们在何处被指定，设置<code style="box-sizing: inherit;">async</code>&nbsp;的脚本的加载有着较低的优先级。他们通常在所有其他脚本加载之后才加载，而不阻塞 DOM 构建。然而，如果一个指定<code style="box-sizing: inherit;">async</code>&nbsp;的脚本很快就完成了下载，那么它的执行会阻塞 DOM 构建以及所有在之后才完成下载的同步脚。</p><p style="box-sizing: inherit;margin-top: 20px;margin-bottom: 1rem;word-wrap: break-word;font-size: 16px;line-height: 27px;color: rgb(55, 58, 60);"><img data-src="http://mmbiz.qpic.cn/mmbiz_png/1NOXMW586uv2pLFk6NGPvhqxgVLiaVcicza0keqwBBvRsyP8tYuunkvgOFCbA2XeaA2e74ZYuRmhcicR1iaAfBpdeQ/0?wx_fmt=png" style="box-sizing: inherit; border-style: none; vertical-align: middle; margin-top: 1rem; margin-bottom: 1rem; width: 500px !important; height: 151px !important;" class="img_loading" data-ratio="0.302" data-w="500" data-type="png" _width="500px" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" crossorigin="anonymous" alt="图片"></p><p style="box-sizing: inherit;margin-top: 20px;margin-bottom: 1rem;word-wrap: break-word;font-size: 16px;line-height: 27px;color: rgb(55, 58, 60);">注: async 和 defer 属性只对外部脚本起作用，如果没有&nbsp;<code style="box-sizing: inherit;">src</code>&nbsp;属性它们会被忽略。</p><h2 style="box-sizing: inherit;margin-top: 20px;margin-bottom: 0.5rem;"><strong><span style="font-size: 20px;">preload</span></strong></h2><p style="box-sizing: inherit;margin-top: 20px;margin-bottom: 1rem;word-wrap: break-word;font-size: 16px;line-height: 27px;color: rgb(55, 58, 60);">如果你想要延迟处理一些脚本，那么<code style="box-sizing: inherit;">async</code>&nbsp;和&nbsp;<code style="box-sizing: inherit;">defer</code>&nbsp;
非常棒。那网页上那些对用户体验至关重要的东西呢？预解析器很方便，但是它们只会预加载少数类型的资源并遵循其逻辑。通常的目的都是首先交付 
CSS，因为它会阻塞渲染。同步的脚本总是比异步的脚本拥有更高的优先级。视口中可见的图像会比那些底下的图片先下载完。还有字体，视频，SVG... 
总而言之 — 这个过程很复杂。</p><p style="box-sizing: inherit;margin-top: 20px;margin-bottom: 1rem;word-wrap: break-word;font-size: 16px;line-height: 27px;color: rgb(55, 58, 60);">作为作者，你知道哪些资源对你的页面渲染来说是最重要的。它们其中一些经常深藏在 CSS 或者是脚本当中，甚至浏览器需要花上很长一段时间才会发现他们。对于那些重要的资源，你现在可以使用<code style="box-sizing: inherit;">&lt;link rel="preload"&gt;</code>&nbsp;来告诉浏览器你需要尽快地加载它们。</p><p style="box-sizing: inherit;margin-top: 20px;margin-bottom: 1rem;word-wrap: break-word;font-size: 16px;line-height: 27px;color: rgb(55, 58, 60);">你只需要写上:</p><pre style="box-sizing: inherit;"><code style="box-sizing: inherit;">&lt;link rel="preload" href="very_important.js" as="script"&gt;</code></pre><p style="box-sizing: inherit;margin-top: 20px;margin-bottom: 1rem;word-wrap: break-word;font-size: 16px;line-height: 27px;color: rgb(55, 58, 60);">你几乎可以链接到任何东西上，<code style="box-sizing: inherit;">as</code>&nbsp;属性告诉浏览器要下载的是什么。一些可能的值是：</p><ul style="" class="list-paddingleft-2"><li><p style="box-sizing: inherit;word-wrap: break-word;line-height: 27px;"><code style="box-sizing: inherit;">script</code></p></li><li><p style="box-sizing: inherit;word-wrap: break-word;line-height: 27px;"><code style="box-sizing: inherit;">style</code></p></li><li><p style="box-sizing: inherit;word-wrap: break-word;line-height: 27px;"><code style="box-sizing: inherit;">image</code></p></li><li><p style="box-sizing: inherit;word-wrap: break-word;line-height: 27px;"><code style="box-sizing: inherit;">font</code></p></li><li><p style="box-sizing: inherit;word-wrap: break-word;line-height: 27px;"><code style="box-sizing: inherit;">audio</code></p></li><li><p style="box-sizing: inherit;word-wrap: break-word;line-height: 27px;"><code style="box-sizing: inherit;">video</code></p></li></ul><p style="box-sizing: inherit;margin-top: 20px;margin-bottom: 1rem;word-wrap: break-word;font-size: 16px;line-height: 27px;color: rgb(55, 58, 60);">你可以在MDN上查看剩余的内容类型。</p><p style="box-sizing: inherit;margin-top: 20px;margin-bottom: 1rem;word-wrap: break-word;font-size: 16px;line-height: 27px;color: rgb(55, 58, 60);">字
体可能是隐藏在CSS中最重要的东西。它们对页面上文字的渲染非常地关键，但是它们知道浏览器确认它们会被使用之前都不会被加载。 这个检查只发生在 
CSS 已经被解析，应用，并且浏览器已经将 CSS 规则匹配到对应的 DOM 
节点上时。这个过程在页面加载的过程中发生的相当晚，并且常常导致文字渲染中不必要的延迟。你可以通过使用 preload 属性来避免。</p><p style="box-sizing: inherit;margin-top: 20px;margin-bottom: 1rem;word-wrap: break-word;font-size: 16px;line-height: 27px;color: rgb(55, 58, 60);">有一点要注意，要预加载字体你还必须设置crossorigin&nbsp;属性，即使字体在同一个域名下：</p><pre style="box-sizing: inherit;"><code style="box-sizing: inherit;">&lt;link rel="preload" href="font.woff" as="font" crossorigin&gt;</code></pre><p style="box-sizing: inherit;margin-top: 20px;margin-bottom: 1rem;word-wrap: break-word;font-size: 16px;line-height: 27px;color: rgb(55, 58, 60);">preload 特性目前只有有限的支持度，因为其他浏览器还在推出它的过程中。你可以在这里查看进度。</p><h2 style="box-sizing: inherit;margin-top: 20px;margin-bottom: 0.5rem;"><span style="font-size: 20px;"><strong>结论</strong></span></h2><p style="box-sizing: inherit;margin-top: 20px;margin-bottom: 1rem;word-wrap: break-word;font-size: 16px;line-height: 27px;color: rgb(55, 58, 60);">浏览器是自 90 年代以来一直在进化的极其复杂的野兽。我们已经讨论了一些遗留问题以及 Web 开发中的一些最新标准。根据这些指南书写你的代码能够帮助你选择最好的策略来提供更加流畅的浏览器体验。</p><p><br></p><blockquote><p>作者:<span style="color: rgb(55, 58, 60);">Mactavish</span><span style="color: rgba(0, 0, 0, 0.54);font-family: Roboto, sans-serif;">&nbsp;</span></p><p>原文:http://zcfy.cc/article/4224</p></blockquote><p><br></p><section class="" data-tools="135编辑器" data-id="87989" style="border-width: 0px;border-style: none;border-color: initial;box-sizing: border-box;"><section class="__bg_gif" style="padding: 30px;border-width: 3px;border-style: double;border-color: rgb(145, 44, 238);background-image: url(&quot;http://mmbiz.qpic.cn/mmbiz_gif/cZV2hRpuAPjTw2iacM6RJGggO7nTficztvMrrFT6d8NaeExPXJllNbrdTnibB8Jnuwcfcp0599X9g5aGmPDlADN3w/0.gif&quot;);box-sizing: border-box;" data-order="3"><p><span style="font-size: 20px;color: #D84FA9;">Vue中文社区</span><span style="color: #0080FF;font-size: 20px;">&nbsp;</span><span style="color: #0080FF;font-size: 12px;">独家公众号，面向前端爱好者， 每日更新最有料的文章，最前沿的资讯,内容包含但不限于Vue,React,Angular,前端工程化...等各种"<span style="color: #D84FA9;">大保健</span>"知识点,右上角点关注,老司机带你弯道超车,不定期更有各种福利赠送</span>&nbsp;</p></section></section><p><br></p><p style="max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);line-height: 25.6px;text-align: center;box-sizing: border-box !important;word-wrap: break-word !important;"><span style="max-width: 100%;color: #548DD4;box-sizing: border-box !important;word-wrap: break-word !important;">FEweekly</span></p><section class="" data-tools="135编辑器" data-id="86357" data-color="rgb(89, 195, 249)" data-custom="rgb(89, 195, 249)" style="max-width: 100%;box-sizing: border-box;background-color: rgb(255, 255, 255);border-width: 0px;border-style: none;border-color: initial;word-wrap: break-word !important;"><section style="max-width: 100%;text-align: center;box-sizing: border-box !important;word-wrap: break-word !important;"><section style="max-width: 100%;display: inline-block;width: 192px;box-sizing: border-box !important;word-wrap: break-word !important;"><img class="" data-ratio="0.125" data-src="http://mmbiz.qpic.cn/mmbiz/cZV2hRpuAPialHghKLjic2ibD7sFcuQ6wrakMrFv47qt1Lib5BD10KWLibRMLZbdQtY2TwasT3klmETSDmgXziaH3pOQ/640" data-w="600" style="display: inline; box-sizing: border-box !important; overflow-wrap: break-word !important; visibility: visible !important; width: 192px !important; height: 24px !important;" title="墨迹晕染分割线" _width="192px" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" crossorigin="anonymous" alt="图片" width="192px"></section></section></section>
                
        </body>
        </html>