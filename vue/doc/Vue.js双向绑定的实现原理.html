<!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Title</title>
        </head>
        <body>
        
                    

                    
                    
                    
                    <blockquote style="box-sizing: inherit;padding-left: 1.2em;margin-top: 20px;margin-bottom: 20px;color: rgb(51, 51, 51);border-left-width: 4px;border-left-color: rgb(226, 227, 228);"></blockquote><p style="box-sizing: border-box;"><span style="box-sizing: border-box;font-size: 16px;"><strong style="box-sizing: border-box;"></strong></span></p><p style="text-align: left;box-sizing: border-box;"><span style="box-sizing: border-box;font-size: 16px;">&nbsp; &nbsp; &nbsp; &nbsp;Vue.js 最核心的功能有两个，一是响应式的数据绑定系统，二是组件系统。本文仅探究双向绑定是怎样实现的。先讲涉及的知识点，再用简化得不能再简化的代码实现一个简单的 hello world 示例。</span></p><p style="box-sizing: border-box;text-align: left;"><span style="box-sizing: border-box;font-size: 16px;">&nbsp;　　参考文章：https://segmentfault.com/a/1190000006599500</span></p><p style="box-sizing: border-box;"><span style="box-sizing: border-box;font-size: 18px;"><strong style="box-sizing: border-box;">一、访问器属性</strong></span></p><p style="box-sizing: border-box;"><span style="box-sizing: border-box;font-size: 16px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 访问器属性是对象中的一种特殊属性，它不能直接在对象中设置，而必须通过 defineProperty() 方法单独定义。</span></p><p style="box-sizing: border-box;"><span style="box-sizing: border-box;font-size: 16px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var obj = { };</span></p><p style="box-sizing: border-box;"><span style="box-sizing: border-box;font-size: 16px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 为obj定义一个名为 hello 的访问器属性</span></p><p style="box-sizing: border-box;"><span style="box-sizing: border-box;font-size: 16px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Object.defineProperty(obj, "hello", {</span></p><p style="box-sizing: border-box;"><span style="box-sizing: border-box;font-size: 16px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; get: function () {return sth},</span></p><p style="box-sizing: border-box;"><span style="box-sizing: border-box;font-size: 16px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; set: function (val) {/* do sth */}</span></p><p style="box-sizing: border-box;"><span style="box-sizing: border-box;font-size: 16px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; })</span></p><p style="box-sizing: border-box;"><span style="box-sizing: border-box;font-size: 16px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; obj.hello // 可以像普通属性一样读取访问器属性</span></p><p style="box-sizing: border-box;"><span style="box-sizing: border-box;font-size: 16px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 访问器属性的"值"比较特殊，读取或设置访问器属性的值，实际上是调用其内部特性：get和set函数。</span></p><p style="box-sizing: border-box;"><span style="box-sizing: border-box;font-size: 16px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; obj.hello // 读取属性，就是调用get函数并返回get函数的返回值</span></p><p style="box-sizing: border-box;"><span style="box-sizing: border-box;font-size: 16px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; obj.hello = "abc" // 为属性赋值，就是调用set函数，赋值其实是传参</span><span style="box-sizing: border-box;font-size: 16px;">&nbsp;<img data-src="http://mmbiz.qpic.cn/mmbiz_png/1NOXMW586uvuibfkKC8xjL1a27jAibGfYFUdSve3EUy29ftnRibBBhCiajKlzFDXPPKbXQAPLZnQJgUxzObIjgNRjQ/0?wx_fmt=png" style="box-sizing: border-box; border-width: 0px; border-style: initial; border-color: initial; width: 677px !important; height: auto !important; visibility: visible !important;" class="" data-type="png" data-ratio="0.37604166666666666" data-w="960" _width="677px" src="Vue.js%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86_files/640.webp" crossorigin="anonymous" alt="图片" data-fail="0"></span></p><p style="box-sizing: border-box;"><span style="box-sizing: border-box;font-size: 16px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 get 和 set 方法内部的 this 都指向 obj，这意味着 get 和 set 
函数可以操作对象内部的值。另外，访问器属性的会"覆盖"同名的普通属性，因为访问器属性会被优先访问，与其同名的普通属性则会被忽略。</span></p><p style="box-sizing: border-box;"><span style="box-sizing: border-box;font-size: 16px;">&nbsp;</span></p><p style="box-sizing: border-box;"><span style="box-sizing: border-box;font-size: 18px;"><strong style="box-sizing: border-box;">二、极简双向绑定的实现</strong></span></p><p style="box-sizing: border-box;"><span style="box-sizing: border-box;font-size: 16px;"><img data-src="http://mmbiz.qpic.cn/mmbiz_png/1NOXMW586uvuibfkKC8xjL1a27jAibGfYFmt11REjoHefJKkj7MBKntLQ5FuhuRZwibCeLbOhq8vRrsptKtPIQrqQ/0?wx_fmt=png" style="box-sizing: border-box; border-width: 0px; border-style: initial; border-color: initial; width: 677px !important; height: auto !important; visibility: visible !important;" class="" data-type="png" data-ratio="0.5010416666666667" data-w="960" _width="677px" src="Vue.js%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86_files/640_002.webp" crossorigin="anonymous" alt="图片" data-fail="0"></span></p><p style="box-sizing: border-box;"><span style="box-sizing: border-box;font-size: 16px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 此例实现的效果是：随文本框输入文字的变化，span 中会同步显示相同的文字内容；在js或控制台显式的修改 obj.hello 
的值，视图会相应更新。这样就实现了 model =&gt; view 以及 view =&gt; model 的双向绑定。</span></p><p style="box-sizing: border-box;"><span style="box-sizing: border-box;font-size: 16px;">&nbsp;<img data-src="http://mmbiz.qpic.cn/mmbiz_png/1NOXMW586uvuibfkKC8xjL1a27jAibGfYFg8eFJzfSSLU3bBbqTTlv1ADnukWROBHOazRrjiblHKXACFNcZOu1xQA/0?wx_fmt=png" style="box-sizing: border-box; border-width: 0px; border-style: initial; border-color: initial; width: 677px !important; height: auto !important; visibility: visible !important;" class="" data-type="png" data-ratio="0.159375" data-w="960" _width="677px" src="Vue.js%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86_files/640.png" crossorigin="anonymous" alt="图片" data-fail="0"></span></p><p style="box-sizing: border-box;"><span style="box-sizing: border-box;font-size: 16px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 以上就是 Vue 实现双向绑定的基本原理。</span></p><p style="box-sizing: border-box;"><span style="box-sizing: border-box;font-size: 16px;">&nbsp;</span></p><p style="box-sizing: border-box;"><span style="box-sizing: border-box;font-size: 18px;"><strong style="box-sizing: border-box;">三、分解任务</strong></span></p><p style="box-sizing: border-box;"><span style="box-sizing: border-box;font-size: 16px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 上述示例仅仅是为了说明原理。我们最终要实现的是：</span></p><p style="box-sizing: border-box;"><span style="box-sizing: border-box;font-size: 16px;"><img data-src="http://mmbiz.qpic.cn/mmbiz_png/1NOXMW586uvuibfkKC8xjL1a27jAibGfYFiadIldnE8Naib7BCWxDmh6MiaMTqOu6LN8TFpa38w805M2LyJXr5CW8Xw/0?wx_fmt=png" style="box-sizing: border-box; border-width: 0px; border-style: initial; border-color: initial; width: 677px !important; height: auto !important; visibility: visible !important;" class="" data-ratio="0.128125" data-w="960" data-type="png" _width="677px" src="Vue.js%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86_files/640_003.webp" crossorigin="anonymous" alt="图片" data-fail="0"></span></p><p style="box-sizing: border-box;"><span style="box-sizing: border-box;font-size: 16px;"><img data-src="http://mmbiz.qpic.cn/mmbiz_png/1NOXMW586uvuibfkKC8xjL1a27jAibGfYFle3yQb7aFsy7dQyFhU8On8OVV9LkiakL3YXGOOyDEaeGroTNIcB2dAg/0?wx_fmt=png" style="box-sizing: border-box; border-width: 0px; border-style: initial; border-color: initial; width: 677px !important; height: auto !important; visibility: visible !important;" class="" data-type="png" data-ratio="0.1875" data-w="960" _width="677px" src="Vue.js%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86_files/640_005.webp" crossorigin="anonymous" alt="图片" data-fail="0"></span></p><p style="box-sizing: border-box;"><span style="box-sizing: border-box;font-size: 16px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 首先将该任务分成几个子任务：</span></p><p style="box-sizing: border-box;"><span style="box-sizing: border-box;font-size: 16px;">　　 1、输入框以及文本节点与 data 中的数据绑定</span></p><p style="box-sizing: border-box;"><span style="box-sizing: border-box;font-size: 16px;">　　 2、输入框内容变化时，data 中的数据同步变化。即 view =&gt; model 的变化。</span></p><p style="box-sizing: border-box;"><span style="box-sizing: border-box;font-size: 16px;">　　 3、data 中的数据变化时，文本节点的内容同步变化。即 model =&gt; view 的变化。</span></p><p style="box-sizing: border-box;"><span style="box-sizing: border-box;font-size: 16px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 要实现任务一，需要对 DOM 进行编译，这里有一个知识点：DocumentFragment。</span></p><p style="box-sizing: border-box;"><span style="box-sizing: border-box;font-size: 16px;">&nbsp;</span></p><p style="box-sizing: border-box;"><span style="box-sizing: border-box;font-size: 18px;"><strong style="box-sizing: border-box;">四、DocumentFragment</strong></span></p><p style="box-sizing: border-box;"><span style="box-sizing: border-box;font-size: 16px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 DocumentFragment（文档片段）可以看作节点容器，它可以包含多个子节点，当我们将它插入到 DOM 
中时，只有它的子节点会插入目标节点，所以把它看作一组节点的容器。使用 DocumentFragment 处理节点，速度和性能远远优于直接操作 
DOM。Vue 进行编译时，就是将挂载目标的所有子节点劫持（真的是劫持，通过&nbsp;append 方法，DOM 中的节点会被自动删除）到 
DocumentFragment 中，经过一番处理后，再将 DocumentFragment 整体返回插入挂载目标。</span></p><p style="box-sizing: border-box;"><span style="box-sizing: border-box;font-size: 16px;"><img data-src="http://mmbiz.qpic.cn/mmbiz_png/1NOXMW586uvuibfkKC8xjL1a27jAibGfYF7ufAPfU4N9FVKgRHiaba2oDDfQ7gtlaGO40hicjdw83RzPGt5DRG4omw/0?wx_fmt=png" style="box-sizing: border-box; border-width: 0px; border-style: initial; border-color: initial; width: 677px !important; height: auto !important; visibility: visible !important;" class="" data-type="png" data-ratio="0.6260416666666667" data-w="960" _width="677px" src="Vue.js%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86_files/640_004.webp" crossorigin="anonymous" alt="图片" data-fail="0"></span></p><p style="box-sizing: border-box;">&nbsp;</p><p style="box-sizing: border-box;"># 勘误：flag.append() 应为 flag.appendChild()。下同。在 Chrome 中用 append() 竟然正常，没报错。</p><p style="box-sizing: border-box;"><span style="box-sizing: border-box;font-size: 16px;"><img data-src="http://mmbiz.qpic.cn/mmbiz_png/1NOXMW586uvuibfkKC8xjL1a27jAibGfYF5knB7ibEg2t4IIuz6W72fY7TAsHiaVibs6rlIPeEK9VX4Hmn6ay0icTTyA/0?wx_fmt=png" style="box-sizing: border-box; border-width: 0px; border-style: initial; border-color: initial; width: 677px !important; height: 98.7292px !important;" class="img_loading" data-ratio="0.14583333333333334" data-w="960" data-type="png" _width="677px" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" crossorigin="anonymous" alt="图片"></span></p><p style="box-sizing: border-box;"><span style="box-sizing: border-box;font-size: 16px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p><p style="box-sizing: border-box;"><span style="box-sizing: border-box;font-size: 18px;"><strong style="box-sizing: border-box;">五、数据初始化绑定</strong></span></p><p style="box-sizing: border-box;"><span style="box-sizing: border-box;font-size: 16px;"><img data-src="http://mmbiz.qpic.cn/mmbiz_png/1NOXMW586uvuibfkKC8xjL1a27jAibGfYFiaHnlE7pL5ZJ6OKq8e4KQBw7XYd7dghknzCZ0Y8Nia84LeAhTk9K9UbQ/0?wx_fmt=png" style="box-sizing: border-box; border-width: 0px; border-style: initial; border-color: initial; width: 677px !important; height: 490.631px !important;" class="img_loading" data-ratio="0.7247132429614181" data-w="959" data-type="png" _width="677px" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" crossorigin="anonymous" alt="图片"></span></p><p style="box-sizing: border-box;"><span style="box-sizing: border-box;font-size: 16px;"><img data-src="http://mmbiz.qpic.cn/mmbiz_png/1NOXMW586uvuibfkKC8xjL1a27jAibGfYFx4HpFianYnOJ1bTcyFdtibM3hHVd7ncl5QmKuxc6p4b64dSKqBXSHWjA/0?wx_fmt=png" style="box-sizing: border-box; border-width: 0px; border-style: initial; border-color: initial; width: 677px !important; height: 236.95px !important;" class="img_loading" data-ratio="0.35" data-w="960" data-type="png" _width="677px" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" crossorigin="anonymous" alt="图片"></span></p><p style="box-sizing: border-box;"><span style="box-sizing: border-box;font-size: 16px;"><img data-src="http://mmbiz.qpic.cn/mmbiz_png/1NOXMW586uvuibfkKC8xjL1a27jAibGfYFrHgzZt9eG1XNMbGkedDicV4suSBLayIJaDRLUibMzqWFJA7dgqppZZ4A/0?wx_fmt=png" style="box-sizing: border-box; border-width: 0px; border-style: initial; border-color: initial; width: 677px !important; height: 300.419px !important;" class="img_loading" data-ratio="0.44375" data-w="960" data-type="png" _width="677px" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" crossorigin="anonymous" alt="图片"></span></p><p style="box-sizing: border-box;"><span style="box-sizing: border-box;font-size: 16px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 以上代码实现了任务一，我们可以看到，hello world已经呈现在输入框和文本节点中。</span></p><p style="box-sizing: border-box;"><span style="box-sizing: border-box;font-size: 16px;"><img data-src="http://mmbiz.qpic.cn/mmbiz_png/1NOXMW586uvuibfkKC8xjL1a27jAibGfYFVO0PH0vDyPpa5XT6AlJqA85ELuQdFvs1HiaKUyxdWOluBSRxsibRmZuw/0?wx_fmt=png" style="box-sizing: border-box; border-width: 0px; border-style: initial; border-color: initial; width: 677px !important; height: 174.892px !important;" class="img_loading" data-ratio="0.25833333333333336" data-w="960" data-type="png" _width="677px" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" crossorigin="anonymous" alt="图片"></span></p><p style="box-sizing: border-box;">&nbsp;</p><p style="box-sizing: border-box;"><span style="box-sizing: border-box;font-size: 18px;"><strong style="box-sizing: border-box;">六、响应式的数据绑定</strong></span></p><p style="box-sizing: border-box;"><span style="box-sizing: border-box;font-size: 16px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 再来看任务二的实现思路：当我们在输入框输入数据的时候，首先触发 input 事件（或者 keyup、change 
事件），在相应的事件处理程序中，我们获取输入框的 value 并赋值给 vm 实例的 text 属性。我们会利用 defineProperty 将
 data 中的 text 设置为 vm 的访问器属性，因此给 vm.text 赋值，就会触发 set 方法。在 set 
方法中主要做两件事，第一是更新属性的值，第二留到任务三再说。</span></p><p style="box-sizing: border-box;"><span style="box-sizing: border-box;font-size: 16px;"><img data-src="http://mmbiz.qpic.cn/mmbiz_png/1NOXMW586uvuibfkKC8xjL1a27jAibGfYFoxT9SVv7Zicg7iaJ5WffIRQURJFIgjymqIWUXYgDzH1CuRZVu0Ls17Bw/0?wx_fmt=png" style="box-sizing: border-box; border-width: 0px; border-style: initial; border-color: initial; width: 677px !important; height: 637.508px !important;" class="img_loading" data-ratio="0.9416666666666667" data-w="960" data-type="png" _width="677px" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" crossorigin="anonymous" alt="图片"></span></p><p style="box-sizing: border-box;"><span style="box-sizing: border-box;font-size: 16px;"><img data-src="http://mmbiz.qpic.cn/mmbiz_png/1NOXMW586uvuibfkKC8xjL1a27jAibGfYFgJQFJLuicibGGuBbWokWvIvDjkRF0t4xE7WZxahZwW4DD1Sls74y2BPA/0?wx_fmt=png" style="box-sizing: border-box; border-width: 0px; border-style: initial; border-color: initial; width: 677px !important; height: 575.45px !important;" class="img_loading" data-ratio="0.85" data-w="960" data-type="png" _width="677px" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" crossorigin="anonymous" alt="图片"></span></p><p style="box-sizing: border-box;"><span style="box-sizing: border-box;font-size: 16px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 任务二也就完成了，text 属性值会与输入框的内容同步变化：</span></p><p style="box-sizing: border-box;"><span style="box-sizing: border-box;font-size: 16px;"><img data-src="http://mmbiz.qpic.cn/mmbiz_png/1NOXMW586uvuibfkKC8xjL1a27jAibGfYF6qQfh8ng1ZzFictOgxWgG7RVROkQxAAj5lGgwaDgWC32oaELdHPib3ug/0?wx_fmt=png" style="box-sizing: border-box; border-width: 0px; border-style: initial; border-color: initial; width: 677px !important; height: 206.626px !important;" class="img_loading" data-ratio="0.30520833333333336" data-w="960" data-type="png" _width="677px" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" crossorigin="anonymous" alt="图片"></span></p><p style="box-sizing: border-box;"><span style="box-sizing: border-box;font-size: 16px;">&nbsp;</span></p><p style="box-sizing: border-box;"><span style="box-sizing: border-box;font-size: 18px;"><strong style="box-sizing: border-box;">七、订阅/发布模式（subscribe&amp;publish）</strong></span></p><p style="box-sizing: border-box;"><span style="box-sizing: border-box;font-size: 16px;"><strong style="box-sizing: border-box;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</strong>text 属性变化了，set 方法触发了，但是文本节点的内容没有变化。如何让同样绑定到 text 的文本节点也同步变化呢？这里又有一个知识点：订阅发布模式。</span></p><p style="box-sizing: border-box;"><span style="box-sizing: border-box;font-size: 16px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 订阅发布模式（又称观察者模式）定义了一种一对多的关系，让多个观察者同时监听某一个主题对象，这个主题对象的状态发生改变时就会通知所有观察者对象。</span></p><p style="box-sizing: border-box;"><span style="box-sizing: border-box;font-size: 16px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 发布者发出通知 =&gt; 主题对象收到通知并推送给订阅者 =&gt; 订阅者执行相应操作</span></p><p style="box-sizing: border-box;"><span style="box-sizing: border-box;font-size: 16px;"><img data-src="http://mmbiz.qpic.cn/mmbiz_png/1NOXMW586uvuibfkKC8xjL1a27jAibGfYFNbHxepSxYLiaJSO1J1ol1CRCRXkKKmMLa5AMDq5XnrXsTH4FgyMkyPw/0?wx_fmt=png" style="box-sizing: border-box; border-width: 0px; border-style: initial; border-color: initial; width: 677px !important; height: 468.258px !important;" class="img_loading" data-ratio="0.6916666666666667" data-w="960" data-type="png" _width="677px" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" crossorigin="anonymous" alt="图片"></span></p><p style="box-sizing: border-box;"><span style="box-sizing: border-box;font-size: 16px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 之前提到的，当 set 方法触发后做的第二件事就是作为发布者发出通知：“我是属性 text，我变了”。文本节点则是作为订阅者，在收到消息后执行相应的更新操作。</span></p><p style="box-sizing: border-box;"><span style="box-sizing: border-box;font-size: 16px;">&nbsp;</span></p><p style="box-sizing: border-box;"><span style="box-sizing: border-box;font-size: 18px;"><strong style="box-sizing: border-box;">八、双向绑定的实现</strong></span></p><p style="box-sizing: border-box;"><span style="box-sizing: border-box;font-size: 16px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 回顾一下，每当 new 一个 Vue，主要做了两件事：第一个是监听数据：observe(data)，第二个是编译 HTML：nodeToFragement(id)。</span></p><p style="box-sizing: border-box;"><span style="box-sizing: border-box;font-size: 16px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在监听数据的过程中，会为 data 中的每一个属性生成一个主题对象 dep。</span></p><p style="box-sizing: border-box;"><span style="box-sizing: border-box;font-size: 16px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在编译 HTML 的过程中，会为每个与数据绑定相关的节点生成一个订阅者 watcher，watcher 会将自己添加到相应属性的 dep 中。</span></p><p style="box-sizing: border-box;"><span style="box-sizing: border-box;font-size: 16px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我们已经实现：修改输入框内容 =&gt; 在事件回调函数中修改属性值 =&gt; 触发属性的 set 方法。</span></p><p style="box-sizing: border-box;"><span style="box-sizing: border-box;font-size: 16px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 接下来我们要实现的是：发出通知 dep.notify() =&gt; 触发订阅者的 update 方法 =&gt; 更新视图。</span></p><p style="box-sizing: border-box;"><span style="box-sizing: border-box;font-size: 16px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这里的关键逻辑是：如何将 watcher 添加到关联属性的 dep 中。</span></p><p style="box-sizing: border-box;"><span style="box-sizing: border-box;font-size: 16px;"><img data-src="http://mmbiz.qpic.cn/mmbiz_png/1NOXMW586uvuibfkKC8xjL1a27jAibGfYF7OjQ4vtAJNV90Msic1fYClzlv2G9ica70U85La6ibNmyic1IVuEsusooWw/0?wx_fmt=png" style="box-sizing: border-box; border-width: 0px; border-style: initial; border-color: initial; width: 677px !important; height: 337.795px !important;" class="img_loading" data-ratio="0.49895833333333334" data-w="960" data-type="png" _width="677px" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" crossorigin="anonymous" alt="图片"></span></p><p style="box-sizing: border-box;"><span style="box-sizing: border-box;font-size: 16px;">&nbsp; &nbsp; &nbsp; &nbsp;在编译 HTML 过程中，为每个与 data 关联的节点生成一个 Watcher。Watcher 函数中发生了什么呢？</span></p><p style="box-sizing: border-box;"><span style="box-sizing: border-box;font-size: 16px;"><img data-src="http://mmbiz.qpic.cn/mmbiz_png/1NOXMW586uvuibfkKC8xjL1a27jAibGfYFwYVYxaBPKbuAniaq1YDHofic9BibEhq4vlAQ8jsea6FIA6dEibAZSfGaWg/0?wx_fmt=png" style="box-sizing: border-box; border-width: 0px; border-style: initial; border-color: initial; width: 677px !important; height: 403.379px !important;" class="img_loading" data-ratio="0.5958333333333333" data-w="960" data-type="png" _width="677px" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" crossorigin="anonymous" alt="图片"></span></p><p style="box-sizing: border-box;"><span style="box-sizing: border-box;font-size: 16px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 首先，将自己赋给了一个全局变量 Dep.target；</span></p><p style="box-sizing: border-box;"><span style="box-sizing: border-box;font-size: 16px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 其次，执行了 update 方法，进而执行了 get 方法，get 的方法读取了 vm 的访问器属性，从而触发了访问器属性的 get 
方法，get 方法中将该 watcher 添加到了对应访问器属性的 dep 中；</span></p><p style="box-sizing: border-box;"><span style="box-sizing: border-box;font-size: 16px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 再次，获取属性的值，然后更新视图。</span></p><p style="box-sizing: border-box;"><span style="box-sizing: border-box;font-size: 16px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 最后，将 Dep.target 设为空。因为它是全局变量，也是 watcher 与 dep 关联的唯一桥梁，任何时刻都必须保证 Dep.target 只有一个值。</span></p><p style="box-sizing: border-box;"><span style="box-sizing: border-box;font-size: 16px;"><img data-src="http://mmbiz.qpic.cn/mmbiz_png/1NOXMW586uvuibfkKC8xjL1a27jAibGfYFrdpKagSODYQS2R4FwJyYVedNicFpEUONYvVn3LpJxauxjGjO0bRYTzw/0?wx_fmt=png" style="box-sizing: border-box; border-width: 0px; border-style: initial; border-color: initial; width: 677px !important; height: 380.813px !important;" class="img_loading" data-ratio="0.5625" data-w="960" data-type="png" _width="677px" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" crossorigin="anonymous" alt="图片"></span></p><p style="box-sizing: border-box;"><img data-src="http://mmbiz.qpic.cn/mmbiz_png/1NOXMW586uvuibfkKC8xjL1a27jAibGfYFqeicIVCXJ4aPTtvm4oiadFdhBt7SibiaLT2Y6u0tHBeMoCXXBXNNIUbqkg/0?wx_fmt=png" style="box-sizing: border-box; border-width: 0px; border-style: initial; border-color: initial; width: 677px !important; height: 315.933px !important;" class="img_loading" data-ratio="0.4666666666666667" data-w="960" data-type="png" _width="677px" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" crossorigin="anonymous" alt="图片"></p><p style="box-sizing: border-box;text-align: left;"><span style="box-sizing: border-box;font-size: 16px;">至此，hello world 双向绑定就基本实现了。文本内容会随输入框内容同步变化，在控制器中修改 vm.text 的值，会同步反映到文本内容中。</span></p><p style="box-sizing: border-box;text-align: left;"><span style="box-sizing: border-box;font-size: 16px;">完整代码：</span><span style="box-sizing: border-box;font-size: 16px;">https://github.com/bison1994/two-way-data-binding</span></p><p style="box-sizing: border-box;text-align: left;"><span style="box-sizing: border-box;font-size: 16px;">更详尽的源码分析，可以参考滴滴的这篇文章：https://github.com/DDFE/DDFE-blog/issues/7</span></p><p style="box-sizing: border-box;"><br><span style="font-size: 16px;"></span></p><blockquote><p>作者：kidney</p><p>原文: <span style="color: rgb(51, 51, 51);font-family: Tahoma, simsun, arial;font-size: 12px;background-color: rgb(255, 255, 255);">http://dwz.cn/7bpQ33</span></p></blockquote>
                
        </body>
        </html>